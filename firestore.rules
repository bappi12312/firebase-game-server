rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection
    match /users/{userId} {
      // Allow user to read and update their own profile
      allow read, update: if request.auth != null && request.auth.uid == userId;
      // Allow anyone to create a user profile (e.g., on sign-up)
      // Ensure the request data does not attempt to set the 'role' field unless by an admin later
      allow create: if request.auth != null && (!('role' in request.resource.data) || request.resource.data.role == 'user');
      // Admins can read/write any user profile
      allow read, write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // User votes subcollection
    match /users/{userId}/votes/{serverId} {
      // Allow user to read and write their own votes
      allow read, write: if request.auth != null && request.auth.uid == userId;
       // Admins can read any user vote data (for moderation, etc.)
      allow read: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Servers collection
    match /servers/{serverId} {
      // Allow anyone to read approved servers
      allow read: if resource.data.status == 'approved';

      // Allow authenticated users to create (submit) servers
      // Ensure submittedBy matches the authenticated user and status is 'pending'
      allow create: if request.auth != null &&
                      request.resource.data.submittedBy == request.auth.uid &&
                      request.resource.data.status == 'pending';

      // Allow the user who submitted the server to update it IF it's still pending
      // Allow admins to update any server (e.g., change status, edit details)
      allow update: if request.auth != null &&
                      (
                        (resource.data.submittedBy == request.auth.uid && resource.data.status == 'pending'
                         && !(request.resource.data.diff(resource.data).affectedKeys().hasAny(['status', 'votes']))) || // User cannot change status or votes
                        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
                      );

      // Allow admins to delete servers
      allow delete: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';

      // For voting (specific field update): Allow authenticated users to increment votes and set lastVotedAt if server is approved
      // This needs to be a separate rule or part of a broader update rule with conditions.
      // If using a transaction from a backend/secure function, this rule might be simpler.
      // For client-side, ensure the update only touches 'votes' and 'lastVotedAt'.
      // This specific rule `allow update (votes, lastVotedAt): ...` is not standard Firestore syntax.
      // Instead, handle this within the broader `allow update` by checking `request.resource.data.diff(resource.data).affectedKeys()`.
      // The general update rule above now covers admins. For user voting:
      // A Cloud Function triggered by a vote document write is a more secure way to update server votes.
      // If client-side voting updates the server document directly:
      // match /servers/{serverId} {
      //  allow update: if request.auth != null &&
      //                  resource.data.status == 'approved' &&
      //                  request.resource.data.votes == resource.data.votes + 1 && // ensure only incrementing by 1
      //                  request.resource.data.diff(resource.data).affectedKeys().hasOnly(['votes', 'lastVotedAt']);
      // }
      // However, the current setup updates the server doc and a user-specific vote doc in a batch.
      // The `allow update` rule needs to accommodate this.
      // For simplicity, the main `allow update` for admins is kept. Client vote logic should be carefully reviewed for security.
      // A secure approach is to have votes written to a `votes` collection, and a Cloud Function aggregates them.

      // Admins can read any server regardless of status
      allow read: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Games collection (currently static in app, but if moved to Firestore)
    // match /games/{gameId} {
    //   allow read: if true; // Publicly readable
    //   allow write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'; // Admin only
    // }
  }
}
